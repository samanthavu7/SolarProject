/* Solar Project
 * Jeffrey Hsieh (2016-2017), Ji Hwan Kim(2017-), Samantha Vu(2017), and Amanda Cao (2017-)
 * 
 * ADD PROPER REFERENCES
 * The following code contains open-source references from MIT.
 * Several modications has been made to meet the objective of this research.
 * Credits can be found in header files or online by searching Adafruit tutorials. 
 */
#include "SolarProject.h"
#include "buttons.h"
#include "screen.h"
#include "sensors.h"
#include "speedcontrol.h" //speedcontrol for fans
#include <SD.h> // SD card for saving data

// Define SPI bus for SD usage (begin funct.) ** 
#if defined __AVR_ATmega2560__
  #define SD_MISO 12 //Master In Slave Out: slave line for sending data to the master
  #define SD_MOSI 11 //Master Out Slave In: master line for sending data to the peripherals
  #define SD_SCK 13 //Serial Clock: clock pulses synchronize data transmission generated by master
#endif
#define SD_CS 10 //Chip select pin chosen independent of Arduino type

// Runtime varibles.
int solarTime = 0; //drying time
int nextPosition = 0;

// Time
unsigned long pM = 0;
unsigned long pS = 0;
unsigned long index = 0;
bool secBox = false;
// Change here for time debug: 60000
const long intervalM = 60000;
const long intervalS = 1000;

//int relay1 = 31;
//int relay2 = 33;
//speedcontrol variables
int power_level_ch1 = 0;  // (0-100) User updates this variable to alter CH 1 output
int power_level_ch2 = 0;  // (0-100) User updates this variable to alter CH 2 output [must use zero_cross_independent()]
/*
 * This function provides control to the two triacs. Only use power_level_ch1 if using this function.
 */
void zero_cross() {
  if (power_level_ch1 <= 0) {
    return;
  }
  if (power_level_ch1 > 98) {
    power_level_ch1 = 98;
  }
  // Every zerocrossing: 60Hz (1/2 Cycle) => 8.33ms period
  const int delay_time_ch1 = 8330 - (83 * power_level_ch1); // in microseconds
  delayMicroseconds(delay_time_ch1);  // Off cycle for CH 1
  digitalWrite(channel_1_pin, HIGH);   // Fire triac 1
  digitalWrite(channel_2_pin, HIGH);   // Fire triac 2
  delayMicroseconds(1);         // triac On propogation delay (depends on specs of triac)
  digitalWrite(channel_1_pin, LOW);    // Turn triac 1 off
  digitalWrite(channel_2_pin, LOW);    // Turn triac 2 off
}


const int channel_1_pin = 7;  // Output to Opto Triac pin, channel 1
const int channel_2_pin = 8;  // Output to Opto Triac pin, channel 2
const int sync_pin = 2;       // This pin connects to the output of the zero crossing circuit

// Define file for SD card. **140 bytes per log session.
File solarData;

// Write function.
void writeData(){
  solarData.println("\tS1\tS2\tS3\tS4\tS5\tS6\tS7\tS8\t");
  solarData.print("T\t"); 
  solarData.print(t1);
  solarData.print(degree);
  solarData.print("C\t");
  solarData.print(t2);
  solarData.print(degree);
  solarData.print("C\t");
  solarData.print(t3);
  solarData.print(degree);
  solarData.print("C\t");
  solarData.print(t4);
  solarData.print(degree);
  solarData.print("C\t");
  solarData.print(t5);
  solarData.print(degree);
  solarData.print("C\t");
  solarData.print(t6);
  solarData.print(degree);
  solarData.print("C\t");
  solarData.print(t7);
  solarData.print(degree);
  solarData.print("C\t");
  solarData.print(t8);
  solarData.print(degree);
  solarData.println("C");
  solarData.print("H\t");
  solarData.print(h1);
  solarData.print("%\t");
  solarData.print(h2);
  solarData.print("%\t");
  solarData.print(h3);
  solarData.print("%\t");
  solarData.print(h4);
  solarData.print("%\t");
  solarData.print(h5);
  solarData.print("%\t");
  solarData.print(h6);
  solarData.print("%\t");
  solarData.print(h7);
  solarData.print("%\t");
  solarData.print(h8);
  solarData.println("%\n");
  solarData.println("\n");
}

// State Machine.
enum Solar{Initial, Wait, Execute, Pause, /*Emergency*/}phase;

void solar(){
  switch(phase)
  {
    case Initial: // Setting up the program.
      solarTime = 10;
      nextPosition = tft.height()-10; //Check
      initializeButtons(); //create start, stop buttons, time bar
      currentButton = "START";
      selectedButton = "";
      highlight();     
     
      phase = Execute;
      
      break;

    case Wait: // Listening for inputs.
//       digitalWrite(relay1, LOW); //Neccessary?
//       digitalWrite(relay2, LOW);
      
      if(currentButton == "START") {
        if(digitalRead(buttonDown) == HIGH) {
          currentButton = "BAR";
          highlight();
        }
        else if(digitalRead(buttonEnter) == HIGH) { //solarTime cannot be 0?
          if(solarTime != 0) {
            selectedButton = "START";
            highlight();
            createInterface(solarTime);

            phase = Execute;
            break;
          }
        }
      }
      else if(currentButton == "BAR") {
        if(barEntered) {
          //get button states first
          upState = digitalRead(buttonUp);
          downState = digitalRead(buttonDown);
          //if entered, exit the bar
          if(digitalRead(buttonEnter) == HIGH) { 
            barEntered = false;
            selectedButton = "";
            highlight();
          }
          //debouncing - anything pressed with interval of 1 sec is taken as single press
          else if ( (millis() - lastDebounceTime) > debounceDelay) {
            if (upState == HIGH) {
              ++solarTime;
              --nextPosition;
              tft.fillRect(timeBox, tft.height()-solarTime-10, BOXSIZE, solarTime+10, BLACK); //time bar fillRect(x,y,width,length,color), (0,0) coordinate is in the upper left hand corner of the screen
              tft.fillRect(timeBox, 0, BOXSIZE, tft.height()-solarTime-10, PASTELGREEN);
              createInterface(solarTime);
              lastDebounceTime = millis(); //set the current time
            }
            if (downState == HIGH) {
              --solarTime;
              tft.fillRect(timeBox, tft.height()-solarTime-10, BOXSIZE, solarTime+10, BLACK);
              tft.fillRect(timeBox, 0, BOXSIZE, tft.height()-solarTime-10, PASTELGREEN);
              ++nextPosition;
              createInterface(solarTime);
              lastDebounceTime = millis(); //set the current time
            }
          }
          //press and hold case: increase continuosly until let go
          else {
            if (upState == HIGH) {
              while (digitalRead(buttonUp) == HIGH) {
                  ++solarTime;
                  --nextPosition;
                  tft.fillRect(timeBox, tft.height()-solarTime-10, BOXSIZE, solarTime+10, BLACK); //time bar fillRect(x,y,width,length,color), (0,0) coordinate is in the upper left hand corner of the screen
                  tft.fillRect(timeBox, 0, BOXSIZE, tft.height()-solarTime-10, PASTELGREEN);
                  createInterface(solarTime);
              }
            }
            else if (downState == HIGH){
              while (digitalRead(buttonDown) == HIGH) {
                  --solarTime;
                  tft.fillRect(timeBox, tft.height()-solarTime-10, BOXSIZE, solarTime+10, BLACK);
                  tft.fillRect(timeBox, 0, BOXSIZE, tft.height()-solarTime-10, PASTELGREEN);
                  ++nextPosition;
                  createInterface(solarTime);
              }
            }
           }
//           if(digitalRead(buttonUp) == HIGH && solarTime < 180) {
//             ++solarTime;
//             --nextPosition;
//             tft.fillRect(timeBox, tft.height()-solarTime-10, BOXSIZE, solarTime+10, BLACK); //time bar fillRect(x,y,width,length,color), (0,0) coordinate is in the upper left hand corner of the screen
//             tft.fillRect(timeBox, 0, BOXSIZE, tft.height()-solarTime-10, PASTELGREEN);
//             createInterface(solarTime);
//           }
//           else if(digitalRead(buttonDown) == HIGH && solarTime > 0) {
//             --solarTime;
//             tft.fillRect(timeBox, tft.height()-solarTime-10, BOXSIZE, solarTime+10, BLACK);
//             tft.fillRect(timeBox, 0, BOXSIZE, tft.height()-solarTime-10, PASTELGREEN);
//             ++nextPosition;
//             createInterface(solarTime);
//           }
//           else if(digitalRead(buttonEnter) == HIGH) { 
//             barEntered = false;
//             selectedButton = "";
//             highlight();
//           }
        }
        else { //bar not entered
          if(digitalRead(buttonEnter) == HIGH) {
            barEntered = true;
            selectedButton = "BAR";
            highlight();
          }
          else if(digitalRead(buttonUp) == HIGH) {
            currentButton = "START";
            highlight();
          }
        }
      }
    
      break;
      
    case Execute:
//      digitalWrite(relay1, HIGH);
//      digitalWrite(relay2, HIGH);
      
      
      currentButton = "STOP"; 
      highlight();
      
      if(digitalRead(buttonEnter) == HIGH) {
        selectedButton = "STOP";
        highlight();
        
        phase = Pause;
        break;
      }
      
      phase = (solarTime > 0) ? Execute : Pause;
      break;
      
    case Pause:
//      digitalWrite(relay1, LOW);
//      digitalWrite(relay2, LOW);

      if(solarTime <= 0){ //less than?
        phase = Initial;
        break;
      }
      
      currentButton = "START";
      highlight();

      if(digitalRead(buttonEnter) == HIGH) {
        selectedButton = "START";
        highlight();
        
        phase = Execute;
        break;
      }
    /*case Emergency:
        //emergencyScreen();
        soundAlarm();
        if(digitalRead(buttonEnter) == HIGH) {
          //turn off alarm
          tft.fillScreen(PASTELGREEN);
          createInterface(solarTime);
          phase = Pause;
        }
        break;*/
      break;
  }
}

void setup() {
  Serial.begin(9600); //? Will need to have user open serial every time :-(
  
  #if defined __AVR_ATmega2560__
  // Begin SD usage.
  if(!SD.begin(SD_CS, SD_MOSI, SD_MISO, SD_SCK)){
     Serial.println("Error: unable to detect SD card.");
  }
  #else
  
  // Begin SD usage.
  if(!SD.begin(SD_CS)){
     Serial.println("Error: unable to detect SD card.");
  }
  #endif
  
  tft.reset();
  uint16_t identifier = tft.readID();
  tft.begin(identifier);

  //Background color
  tft.fillScreen(PASTELGREEN);
  tft.setRotation(2);

  markers();
  
  // Begin DHT sensors.
  solar1.begin();
  solar2.begin();
  solar3.begin();
  solar4.begin();
  solar5.begin();
  solar6.begin();
  solar7.begin();
  solar8.begin();

  createInterface(180);
  initializeButtons();
  
  //pinMode(button, INPUT);

  // Setup devices
//  pinMode(relay1, OUTPUT);
//  pinMode(relay2, OUTPUT);
   
  pinMode(buttonUp, INPUT);
  pinMode(buttonDown, INPUT);
  pinMode(buttonEnter, INPUT);
  //pinMode(buttonEmergency, INPUT);
  //pinMode(ledEmergency, OUTPUT);

  pinMode(channel_1_pin, OUTPUT);// Set AC Load pin as output
  pinMode(channel_2_pin, OUTPUT);// Set AC Load pin as output
  pinMode(sync_pin, INPUT);
  attachInterrupt(digitalPinToInterrupt(sync_pin), zero_cross, RISING);
  // Serial.begin(9600);
}

void loop() {
  unsigned long cM = millis();
  if (cM - pM >= intervalM) {
    pM = cM;
    // Update interface every minute.
    if(index % 1 == 0){
      if(phase == Execute){
        tft.fillRect(timeBox, nextPosition, BOXSIZE, 1, PASTELGREEN);
        ++nextPosition;
        --solarTime;
        createInterface(nextPosition);
      }
    }
    // Log data every 2 minutes.
    if(index % 2 == 0){
      readSensors();
      // Write data to SD card.
      solarData = SD.open("solar.txt", FILE_WRITE);
      if(solarData){
        writeData();
        solarData.close();
      }
      else{
        Serial.println("Error: unable to open solar.txt.");
      }
    }
    index++;
  }
  
  // Box in the upper right-hand corner of the screen blinks every second while the dryer is running
  if(phase == Execute){
    if(cM - pS >= intervalS){ 
      pS = cM;
      if(!secBox){
        tft.drawRect(200, 10, 15, 15, WHITE);
        secBox = true;
      }
      else{
        tft.drawRect(200, 10, 15, 15, PASTELGREEN);
        secBox = false;
      }
    }
    // Emergency Button is pressed-- HIGH turns off LED and vice versa bc...?
    /*if (digitalRead(buttonEmergency) == HIGH) {
      digitalWrite(ledEmergency,LOW);
      // FIXME: add lock-down function
      emergencyScreen();
      phase = Emergency;
    } else {
      digitalWrite(ledEmergency,HIGH);
    }*/
  }
  solar();
}
